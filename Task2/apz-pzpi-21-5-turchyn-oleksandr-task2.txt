1 ОПИС АРХІТЕКТУРИ СИСТЕМИ

У програмній системі попереднього замовлення їжі та напоїв є три типи користувачів: Адміністратори, Користувачі та Партнери-інтегратори. Користувачі взаємодіють з веб-частиною та мобільним додатком для перегляду меню, замовлення їжі та напоїв, оплати замовлень і відстеження статусу своїх замовлень. Адміністратори взаємодіють з веб-частиною для адміністрування системи, включаючи створення, редагування та видалення даних користувачів, керування меню, управління замовленнями, а також управління резервними копіями даних. Партнери-інтегратори використовують API для доступу до системи та інтеграції з іншими системами, наприклад, системами доставки, обліку та аналітики.

2 ПОБУДОВА ДІАГРАМИ РОЗГОРТАННЯ

Для візуалізації фізичної структури програмної системи – її топології, розподілення системи по вузлах, маршрутів передачі інформації між вузлами – було побудовано діаграму розгортання (див. дод. А). З неї видно, що система складається із рівня серверу бази даних (використовується СУБД PostgreSQL), який пов’язаний із backend-сервером, що містить основну бізнес-логіку системи із використанням веб-фреймворку Django, за допомогою протоколу TCP/IP. Клієнт як із веб-додатку, так і з мобільного застосунку використовує протокол HTTP для виконання запитів і отримання відповідей від backend-сервера. При цьому цей же протокол використовується для виконання запитів із браузера користувача до frontend-сервера. Для отримання інформації про нові замовлення розумний пристрій так само використовує протокол HTTP

3 ОПИС АРХІТЕКТУРИ СЕРВЕРНОЇ ЧАСТИНИ

Архітектура програмної системи побудована за класичним підходом Django – використовується модель Model-View-Controller. Дані у системі мають вигляд об’єктів, тобто створюються класи, поля яких і будуть рядками таблиці бази даних. Завдяки вбудованої у фреймворк ORM відбувається перетворення сказаних класів у таблиці, а пов’язані між собою поля класів – у зв’язки між таблицями.
Для надання API, за допомогою яких інші частини системи зможуть взаємодіяти із серверною частиною застосунку, використовується Django REST framework. Вигляди визначають, які функції будуть доступні через інтерфейс користувача. В межах вигляду визначається набір даних, з якими він працюватиме та серіалізатор, що надасть визначені дані у зручній формі. У рамках даного проекту дані моделей перетворюються у формат JSON для передачі клієнту, адже даний формат є надзвичайно популярним і підтримується більшістю мов програмування, що полегшує розробку клієнтських застосунків для нього. Маршрутизатор задає URL-адреси, що надають доступ до кожного вигляду. Маршрутизатори являють собою верхній рівень API.
Для автентифікації в системі було використано JWT-токени. До них відносять access-токени (токени доступу), які генеруються у разі введення валідних даних користувачем, зберігаються на пристрої-клієнті та передаються з кожним запитом у заголовку, та refresh-токени, які дозволяють згенерувати новий access-токен, коли час дії старого сплив. Перевага такого способу автентифікації полягає у тому, що токени не потрібно зберігати на сервері та вони мають високу надійність, оскільки передбачають наявність цифрового підпису. Можна обрати, який використовувати алгоритм шифрування для генерації JWT-токенів та час дії токена доступу. В рамках розробленої системи використовується алгоритм HS256 та час дії – 60 хвилин.
Для забезпечення цілісності даних і для відновлення системи у випадку аварійної ситуації було реалізовано виконання функцій створення резервних копій та відновлення бази даних зі створених копій. Реалізація цього функціоналу відбувається із використанням бібліотеки django-dbbackup. Створено API, при отриманні POST-запитів до яких викликаються відповідні функції для створення копії чи відновлення, які виконуються в рамках операційної системи, а після завершення операції користувач отримує HTTP-відповідь про її успішність.
Забезпечено захист даних: було встановлено SSL-сертифікат, що дозволяє встановлювати лише безпечне з’єднання із клієнтом. Для керування сертифікатами було створено API, при запиті до якого відбувається оновлення існуючого сертифікату. Програмно реалізовані сповіщення про те, що строк дії сертифікату спливає, аби адміністратор розумів, коли його потрібно оновити.
Основною бізнес-логікою серверної частини системи є реалізація «розумного» підбору: виконується підбір страв, що можуть бути приготовані із вказаних інгредієнтів (див. дод. В), та підбір закладів, у яких можуть бути приготовані вказані страви (див. дод. Г).
В	рамках реалізації підбору страв користувачем у параметрах GET-запиту надсилаються інгредієнти, що мають бути складовими страв, а також кількість інгредієнтів, що можуть бути відсутніми у одній страві. У межах алгоритму отримується список id усіх страв, потім для кожної страви визначається множина її інгредієнтів, знаходиться її різниця із множиною інгредієнтів, переданих користувачем і на основі кількості інгредієнтів, що не входять у отриману множину відсутніх у страві інгредієнтів робиться висновок, чи задовольняє ця страва умовам пошуку. В результаті виконання даного алгоритму отримуються 2 списки – страви, що містять усі інгредієнти, та ті, у яких не вистачає декількох але не більше, ніж вказав користувач.
Для пошуку закладів громадського харчування, у яких можуть бути приготовані вибрані користувачем страви, користувачем задаються відповідні страви а також бажане місцерозташування закладу: країна, місто, вулиця. Алгоритм відбирає усі типи автоматів, що можуть приготувати дану страву, отримує автомати для кожного із закладів, визначає, які давні автомати в сукупності можуть приготувати страви у межах закладу, і якщо множина заданих користувачем страв є підмножиною страв, що можуть бути приготованими у закладі, робиться висновок, що даний заклад відповідає умовам пошуку.

4 ПОБУДОВА ДІАГРАМИ ПРЕЦЕДЕНТІВ

Для наочного відображення й розуміння дій користувача в ході використання програми було спроектовано UseCase UML діаграму (див. рис. 1). Із неї чітко видно, що акторами, які безпосередньо взаємодіють із системою, є адміністратор, який здійснює управління системою і відповідає за її працездатність, користувачі, що мають платну підписку чи безкоштовний акаунт взаємодіють із системою для замовлення і отримання їжі, а також працівники закладів громадського харчування. 
Адміністратор має необмежений доступ до функціоналу керування системою. У його обов’язки входить створення резервних копій бази даних, її відновлення у разі припинення нормального функціонування програмного продукту, здійснення керування сертифікатами, що включає у себе відслідковування строку дії SSL-сертифікату та його оновлення у разі потреби. Та основною роботою, що здійснює даний актор, є керування даними системи. Він керує даними таблиць бази даних, а саме: додає нові дані до таблиць, редагує наявні таблиці, може видаляти зайві сутності, а також переглядати усі дані, пов’язані із таблицею і її вмістом.
Користувач із безкоштовним акаунтом може використовувати основний функціонал, що дозволить йому отримати приготовану страву. Він може У закладі харчування у мобільному додатку відсканувати NFC-мітку, після чого отримає доступ до каталогу страв, що пропонує даний заклад харчування. Після цього є можливість переглянути усі страви, що його цікавлять, у чому може допомогти можливість фільтрації, сортування каталогу, а також функція пошуку у ньому, ознайомитися із інформацією про страви, визначити її наповнення та додати до кошику, відредагувати вміст кошику та зробити замовлення, яке буде приготовано і можна буде отримати відповідно до черги. Даний користувач має право здійснити пошук закладів харчування, що можуть приготувати вибрані ним страви і знаходяться у тій місцевості, яку він вкаже, а також знайти страви, котрі складаються із вибраних користувачем інгредієнтів, при цьому даному актору можна вибрати, скільки із вказаних інгредієнтів може бути відсутніми у складі рецепту страви.
Користувач, що маж платну підписку, може здійснити замовлення страви онлайн на вибраний ним час, а також має привілеї при розрахування черги: він може переміститися одразу в середину черги, яка складається лише з користувачів із безкоштовною підпискою.
Взаємодію із системою також здійснює працівник закладу харчування. Коли у апараті для приготування страви не вистачає певних інгредієнтів, від повідомляє про це і даний актор повинен поповнити запаси інгредієнтів для підтримки обслуговування системою користувачів.

5 ПОБУДОВА ER-ДІАГРАМИ

Створивши концептуальну модель предметної області, було спроектовано базу даних і побудовано ER-діаграму (див. рис. 2). З наведеної вище діаграми видно, що БД має наступні сутності:
-	заклад громадського харчування (дозволяє ідентифікувати заклад, де користувач може замовити їжу, містить також інформацію про розташування);
-	тип автомату (ідентифікує тип автомату, від якого залежить, які страви можуть бути приготовані);
-	автомат закладу харчування (містить інформацію про те, у якому закладі знаходиться даний тип автомату);
-	страва (інформація про страву, що може бути приготована у закладах харчування, які підключені до системи);
-	страва, яку готує тип автомату (вказує, які страви можуть бути приготовані певним типом автомату відповідно до їх конструкції);
-	інгредієнт (складові, з яких автомат готує страви);
-	інгредієнт  у  страві  (визначає,  які  саме  інгредієнти  містяться  у стравах);
-	замовлений користувачем інгредієнт страви (так як користувач може коригувати вміст страви, змінюючи кількісні показники інгредієнтів чи визначаючи їх наявність, то дана таблиця зберігає для кожної замовленої користувачем страви вміст інгредієнтів);
-	користувач (авторизована особа, що може виконувати передбачені системою дії від свого імені);
-	відгук про страву (містить коментарі користувача, що він може залишити після вживання страви, аби поділитися своїми враженнями).
Між сутностями бази даних існують зв’язки, що забезпечують їх взаємодію. Реалізуються зв’язки Б:Б шляхом створення проміжних таблиць, зв’язок із якими є 1:Б:
-	заклад громадського харчування – тип автомату (один заклад громадського харчування може містити декілька автоматів, а один тип автоматів може знаходитися у різних закладах);
-	тип автомату – страва (один тип автомату може готувати різні страви, одну страву може готувати декілька автоматів);
-	страва – інгредієнт (одна страва складається з багатьох інгредієнтів, один інгредієнт входить до складу декількох страв);
-	страва – користувач (одна страва може мати відгуки від різних користувачів, один користувач може залишити відгуки про різні страви);
-	інгредієнт у страві – користувач (один інгредієнт може входити до складу замовлення багатьох користувачів, один користувач замовляє страви з багатьох інгредієнтів).

6 СПЕЦИФІКАЦІЯ REST

Передача даних між частинами системи відбувається через протокол HTTP, а самі дані серіалізовані у формат JSON, що є зручним як для упакування даних, так і розпакування клієнтом. Для взаємодії із даними через реалізовні API використовуються такі методи HTTP-запитів, як GET (отримання), POST (надсилання), PUT та PATCH (повне та часткове оновлення відповідно), DELETE (видалення).
Документація для API формується завдяки фреймворку Swagger, проте також є можливість переглянути альтернативний варіант Redis. У табл. 1 наведено, яким чином можна здійснити виконання запитів до серверної частини для кожної із сутностей.

7 ПОБУДОВА ДІАГРАМИ КОМПОНЕНТІВ

Для опису поведінки окремо узятого об'єкта системи, насамперед реактивного (поведінка якого характеризується його реакцією на зовнішні події), було розроблено діаграму станів (див. дод. Б). Детально показано такі стани користувача, як неавторизований та активний, процес переходу від одного стану до іншого. Чітко видно, в яких станах перебуває об’єкт в рамках експлуатації системи, які кроки потрібно пройти, аби перейти з одного стану в інший.

ВИСНОВКИ

В ході даної лабораторної роботи було розроблено серверну частину програмної системи, створивши базу даних, організувавши взаємодію з нею веб-застосунку, забезпечивши перегляд, додавання, редагування та видалення інформації з неї, розробивши бізнес-логіку системи та надавши API для обробки HTTP-запитів до backend-частини відповідно до специфікації REST в рамках використання фреймворку Django REST Framework.

ДОДАТОК А

Специфікація REST

/catering_establishment/ GET Повертає список закладів у межах системи		
/catering_establishment/{id}/ GET Повертає заклад із вказаним id										
/catering_establishment/ POST Додавання	нового закладу до системи						
/dish/ GET Повертає список  страв у межах системи											
/dish/{id}/	GET	Повертає страву	із вказаним id								
/dish/ POST	Додавання нової страви до системи					
/dish/{id}/	PUT	Заміна	даних про страву				
/dish/{id}/	DELETE	Видалення даних про страву				
/ingredient/ GET Повертає список інгредієнтів у межах системи				
/ingredient/{id}/ GET Повертає інгредієнт  із вказаним id							
/ingredient/ POST	Додавання нового інгредієнту до системи
/ingredient/{id}/ PUT Заміна даних про інгредієнт								
/ingredient/{id}/ DELETE Видалення	даних про інгредієнт									
/user/{id}/	GET	Повертає користувача із вказаним id									
/user/ POST	Додавання нового користувача до системи	
/user/{id}/	PUT	Заміна	даних	про користувача		
/user/{id}/	DELETE Видалення даних про користувача		
/automatic_machine_type/ GET Повертає список автоматів у межах системи							
/automatic_machine_type/{id}/ GET Повертає автомат із вказаним id								
/automatic_machine_type/ POST Додавання нового автомату до системи
/catering_establishment/ GET Повертає список страв, що	можуть	бути приготовані у вказаному закладі харчування

Додаток В

Реалізація пошуку страв, що складаються із вказаних інгредієнтів
1	class AppropriateDishesWithIngredientsList(
2	generics.ListCreateAPIView):
3	"""
4	Надання API для відображення страв, що можуть бути приготовані
5	із вказаних інгредієнтів.
6	"""
7	serializer_class = serializers.AppropriateDishesSerializer
8
9	def get_queryset(self):
10	"""
11	Обробка GET-запиту на отримання списку страв.
12	"""
13	parameter_key = '0'
14	query_parameters = self.request.query_params
15	missed_count_parameter_list = \
16	list(query_parameters.getlist(parameter_key))
17	missed_count_parameter = \
18	int(query_parameters.getlist('1')[0]) \
19	if len(missed_count_parameter_list) >= 1 else 2
20	parameter_set = \
21	set(map(int, list(
22	query_parameters.getlist(parameter_key))))
23	
24	return get_dishes_with_ingredients(
25	parameter_set, missed_count_parameter)
26	
27	
28	def get_dishes_with_ingredients(
29	ingredients: set[int],
30	acceptable_missed_count: int) -> dict[str: list[int]]:
31
32
33	"""
34	Пошук страв, які можуть бути приготовані із інгредієнтів, що
35	входять до списку ingredients. Допускається відсутність
36	acceptable_missed_count інгредієнтів у страві.
37	"""
38
39	dishes = [dish.id for dish in models.Dish.objects.all()]
40	appropriate_dishes = list()
41	almost_appropriate_dishes = list()
42
43	for dish_id in dishes:
44	dish_ingredients = {
45	item.ingredient_id for item in
46	models.DishIngredient.objects.filter(dish=dish_id)}
47	print(dish_ingredients)
48	not_used_ingredients = \
49	dish_ingredients.difference(ingredients)
50	not_used_ingredients_count = len(not_used_ingredients)
51	if not_used_ingredients_count == 0:
52	appropriate_dishes.append(dish_id)
53	elif not_used_ingredients_count <=
54	acceptable_missed_count:
55	almost_appropriate_dishes.append(dish_id)
56	
57	return (
58	models.Dish.objects.filter(
59	id__in=appropriate_dishes),
60	models.Dish.objects.filter(
61	id__in=almost_appropriate_dishes
 
Додаток Г

Реалізація пошуку закладів громадського харчування, у яких можуть приготувати вказані страви
1	class DishSetCateringEstablishments(
2	generics.ListAPIView):
3	"""
4	Надання API для відображення закладів громадського харчування,
5	у яких можна замовити вказані страви.
6	"""
7	serializer_class = \
8	serializers.CateringEstablishmentSerializer
9	
10	def get_queryset(self):
11	"""
12	Обробка GET-запиту на отримання списку закладів.
13	"""
14	query_parameters = self.request.query_params
15	
16	dish_key = 'dish'
17	wish_list = set(map(int, list(
18	query_parameters.getlist(dish_key))))
19	
20	automated_machines_with_given_dishes = \
21	models.AutomaticMachineDish.objects.filter(
22	dish__in=wish_list)
23	automated_machines_types_with_given_dishes = \
24	automated_machines_with_given_dishes. \
25	values_list('automatic_machine_type')
26	dishes_cooked_by_machines = \
27	automated_machines_with_given_dishes.\
28	values_list('dish')
29	
30	machine_type_appropriate_dishes = \
31	get_list_mapped_to_integer(
32	automated_machines_types_with_given_dishes,
33	dishes_cooked_by_machines)
34	
35	catering_establishment_machines = \
36	get_catering_establishment_machines(
37	automated_machines_types_with_given_dishes)
38	
39	catering_establishments_that_cook_given_dishes = \
40	get_catering_establishments_that_cook_given_dishes(
41	machine_type_appropriate_dishes,
42	catering_establishment_machines, wish_list)
43	
44	searched_catering_establishments = \
45	models.CateringEstablishment.objects.filter(
46	id__in=
47	catering_establishments_that_cook_given_dishes)
48	searched_catering_establishments = \
49	choose_catering_establishment_by_location(
50	query_parameters,
51	searched_catering_establishments)
52	
53	return searched_catering_establishments
54	
55
56	def get_list_mapped_to_integer(keys, values):
57	"""
58	Складання словнику із масивів ключів і значень.
59	"""
60	result_dict = defaultdict(set)
61
62	for k in range(len(keys)):
63	result_dict[keys[k][0]].add(values[k][0])
64	
65	return result_dict




